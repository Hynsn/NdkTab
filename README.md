A C++ algorithm std::lib.

### 线性表 

- [顺序存储]
Array 数组类：静态 动态
List -> seqlist 静态 动态

- [链式存储]
单链表
StaticLinkList
循环链表
双向链表
双向循环链表

### Stack - 栈
StaticStack LinkStack
### Queue - 队列
StaticQueue LinkQueue

### SP、Exception、KMP、Sort
- SmartPointer, SharedProinter
- Exception
- HString
- Sort - 选择、插入、冒泡、希尔、归并、快排

### GTree - 树
查找、插入、删除、属性操作、层次遍历
### BTree - 二叉树
查找、插入、删除、清除、属性操作、层次遍历、比较和相加

刷题总结

###

#### 数组
##### 1、数组中重复的数字
解法
- 1、先排序，再遍历 时间复杂度O(nlogn)
- 2、使用HashMap 时间复杂度O(n) 空间复杂度O(n)
- 3、利用数组的下表 +code
##### 2、二维数组查找
一个每一行从左到右递增、每列从上到下递增的二维数组，判断该数组中是否包含某一整数。 code -> fix

归纳总结能力


题目变形
不修改数组找出重复的数字（只能通过查找）+code
参考二分查找算法增加统计的同时找出结果 时间复杂度O（nlogn）空间复杂度O(1)

#### 字符串
替换空格
解法
明确是否可以在原字符串上替换并且保证输入字符串后面有足够空余内存，还是在创建新的字符串做替换。+code

相关题目
合并两个有序的数组，可以考虑从后往前复制减少移动的次数

#### 链表
> 注：代码量少、基础、用法灵活比较适合面试
-  链表的基本操作：添加、删除、查找
##### 从尾到头打印链表
##### 删除链表的节点
##### 链表中倒数第K个节点
##### 反转链表
##### 合并两个有序的链表
##### 两个链表的第一个公共节点

代码设计原理
异常安全性

单例
三种实现方式区别

###7大原则
####目的
降低对象之间的耦合
增加程序的可复用、可扩展性和可维护性

####单一职责
一个类应该有且仅有一个引起它变化的原因
作用：
- 降低类的复杂性
- 提高可读性和可维护性
- 降低修改引起的风险
注意事项
- 高内聚：减少大而全，避免不相关功能的耦合
- 低耦合：减少所需依赖和被依赖的类
那种设计最好？
- 需求（变更和复杂度） -> 职责-> 设计粒度
- 没有好的设计，只有更合适的设计。

#### 开闭原则
对扩展开放，对修改关闭。需求在变化时，不修改源代码的基础上扩展功能。
不“开闭”的坏处：牵一发动全身
好处：
- 测试简单
- 可复用性强
- 稳定性高
如何实现？
接口和抽象类
开放和关闭
- 拓展开放：应对变化
- 修改关闭：保持稳定
注意事项：
- 用抽象构建框架，用实现扩展细节
- 参数类型、引用类型尽量使用接口或抽象类
- 抽象层尽量保持稳定：接口和抽象只负责定义方法，不负责具体实现

#### 迪米特法则（最少知识原则）
一个类对于其他类知道的越少越好，只与直接的朋友通信。
- 朋友：有耦合（依赖、关联、组合、聚合）关系的对象
- 直接的朋友：成员变量、方法参数、方法返回值中的类
- 遵循该法则的设计模式：门面模式、中介模式
好处：
- 降低耦合，提高模块功能的独立性
- 非常实用，能直接用于开发环境
注意事项：
不要干
- objA.getObjB().doSomething()
- objA.getObjB().getObjC.doSomething()
- 避免过度使用，不然会存在大量中间类

#### 依赖倒置
高层模块 -> 接口/抽象类 <- 底层模块
内容：
- 高层不应该直接依赖底层，两者应该基于抽象
- 抽象不应该依赖细节，细节依赖抽象
- 应用于工厂方法设计模式
优点：
- 架构更稳定
- 更好的应对需求的变化
面向接口编程：
- 程序要依赖于抽象接口，不要依赖于具体实现
- 抽象比细节稳定
#### 合成（聚合/组合）复用原则
内容：
尽量使用对象聚合/组合，而不是继承达到复用。
聚合 vs 组合 vs 继承
- 聚合 has -A
- 组合 contains -A
- 继承 is -A
继承复用 vs 合成复用
继承复用
- 优点：简单，实现容易
- 缺点：破坏了封装性，耦合度高、限制灵活性，进行扩展比较麻烦
合成复用
- 优点：维持封装性，降低耦合度，灵活性高
- 缺点：有较多对象时需要管理